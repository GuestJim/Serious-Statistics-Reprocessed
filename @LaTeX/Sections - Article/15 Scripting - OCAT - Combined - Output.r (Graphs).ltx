\section{Scripting: OCAT -- Combined -- Output.r (Graphs)}
\subCustomFunction
The OCAT – Combined – Output.r script is some 25 KB currently, and while I could give a line count, I may make enough tweaks for it to change.
The point is, this is a fairly large file, more than all of the other scripts this article will cover combined in fact, and more than half of it is for the creation of the graphs; the code this section is to cover.
Fortunately, there is a lot of repetition in this portion of the script, thanks to the way \textit{ggplot2} works, so this section should not also be larger than the previous combined.

R does have built-in functions for creating graphs, but when I was first learning how to work with R, I learned of this library for creating graphs and it is what I learned to use.
It works by opening a plot object, with the \textbf{ggplot} function, and then layers are added onto this, somewhat literally as it is the addition symbol connecting layers together.
These layers are what actually create the plots from the data, configure the graph's scales, colors, labels, and more.
Some of these layers are present in every graph, though their specific values may be a little different.
Still, a lot is shared between the graphs so it is not as much code as you may expect.

A couple things I want to mention are that it is possible to assign layers (and even whole plots) to variables, which is actually something I do at the start of this section of the script.
The other is that before I started messing with the text and HTML output described in the previous section, making so much of it functions, I spent the time to do the same thing with the plots.
If you skipped the previous section, this means I have made each graph into its own function, and the reason for this is so I do not need to have multiple copies of the same graph for each data type.
The differences, mainly different scales, are set inside of \textbf{if} statements and then the code for the graphs reference variables, allowing the code to be abstract enough to work with whatever I give it.

\begin{styleR}
if	(multiGPU)	{
	labsGPU	=	labs()
}	else	{
	labsGPU	=	labs(caption = cGPU)
}
\end{styleR}

First up we have this simple switch that checks if it is a multi-GPU situation.
If it is, then the \textbf{labs} layer for all of the graph will be empty and have no impact.
If it is not, then this layer will add a caption to the graph, identifying the current GPU.
Captions appear on the lower right of the graph.
With \textbf{labsGPU} set to this, I can add it to a graph like any layer.

\subsubsection{Means Graph}
\begin{styleR}
graphMEANS	=	function(datatype)	{
	if	(datatype == "MsBetweenPresents")	{
		scale_Y	=	scale_y_continuous(
			name		=	"Frame Time (ms)",
			breaks		=	c(0, round(ytimes, 2)),
			limits		=	c(0, FtimeLimit),
			expand		=	c(0.02, 0),
			sec.axis	=	dup_axis()
		)
	}
	if	(datatype == "MsBetweenDisplayChange")	{
		scale_Y	=	scale_y_continuous(
			name		=	"Refresh Cycles Later (1/60 s)",
			breaks		=	c(0, round(ytimes, 2)),
			labels		=	labelDisp,
			limits		=	c(0, FtimeLimit),
			expand		=	c(0.02, 0),
			sec.axis	=	dup_axis()
		)
	}
	if	(datatype == "MsUntilRenderComplete")	{
		scale_Y	=	scale_y_continuous(
			name		=	"Render Time (ms)",
			breaks		=	c(0, round(ytimes, 2)),
			limits		=	c(0, FtimeLimit),
			expand		=	c(0.02, 0),
			sec.axis	=	dup_axis()
		)
	}
	if	(datatype == "MsEstimatedDriverLag")	{
		scale_Y	=	scale_y_continuous(
			name		=	"Estimated Driver Lag (ms)",
			breaks		=	c(0, round(ytimes, 2)),
			limits		=	c(0, FtimeLimit),
			expand		=	c(0.02, 0),
			sec.axis	=	dup_axis()
		)
	}

	ggplot(data = results, aes(x = GPU, y = get(datatype))) +
	ggtitle(gameQ, subtitle = paste0(datatype, " - Means, Medians, and Percentiles")) + labsGPU +
	geom_hline(yintercept = 1000/60, color = "red") +
	# geom_boxplot(outlier.alpha = 0) +
	stat_summary(fun.data = BoxPerc, geom = "boxplot", width = 0.6) +
	geom_bar(aes(fill = GPU), stat = "summary", fun.y = "mean") + scale_fill_hue() +
	stat_summary(fun.data = BoxPerc, geom = "boxplot", alpha = 0.25, width = 0.6) +
	# geom_boxplot(alpha = 0.50, outlier.alpha = 0.1) +
	facet_grid(rows = vars(API), cols = vars(Location), switch = "y") +
	scale_x_discrete(labels = labelBreak) +
	scale_Y +
	guides(fill = guide_legend(nrow = 1)) + theme(legend.position = "bottom")
}
\end{styleR}

That is a lot, I know, but I do not want to break apart a function when first introducing it.
With it introduced now though, I will do just that.

\begin{styleR}
graphMEANS	=	function(datatype)	{
	if	(datatype == "MsBetweenPresents")	{
		scale_Y	=	scale_y_continuous(
			name		=	"Frame Time (ms)",
			breaks		=	c(0, round(ytimes, 2)),
			limits		=	c(0, FtimeLimit),
			expand		=	c(0.02, 0),
			sec.axis	=	dup_axis()
		)
	}
...
}
\end{styleR}

This \textbf{graphMEANS} function is responsible for making the means graph that shows a bar plot for the arithmetic mean and then custom box plots showing the 0.1\%, 1\%, 99\%, and 99.9\% values and median for each configuration of GPU, location, and API, when applicable.
All it takes for an argument is the \textbf{datatype}, such as MsBetweenPresents.
It would not be hard to change have it support friendlier names, but I prefer to keep in practice using the original column names.

The top half of the function is occupied by \textbf{if} statements checking what \textbf{datatype} is and setting a \textbf{scale\_Y} variable based on that.
There are some differences between these variables, but focusing on just the first, for MsBetweenPresents, should be enough.

The \textbf{scale\_Y} variable is assigned the \textbf{scale\_y\_continuous} layer with a number of arguments.
As the name suggests, this is for controlling the properties of the Y scale or axis.
This is a continuous scale because the data can be anything along a continuous range.
An example of a discrete scale would be the GPUs, because each GPU is a discrete value on that scale.
The X scale for this graph are the GPUs, so it does have a discrete scale, but it does not change based on the data type, so it is with the graph's code.

The arguments I am using for \textbf{scale\_y\_continuous} are \textbf{name}, \textbf{breaks}, \textbf{limits}, \textbf{expand}, and \textbf{sec.axis}.
To make them easier to read and work with, each has its own line and I use tabbing to align the equal signs and the values.

The value for \textbf{name} I think is self-explanatory, so I will move on.

Breaks for a scale are where the tick marks appear on the scale itself, and if you look closely at the background of the graphs, there are white lines following these marks on the plot's background.
There are also minor breaks, controlled with \textbf{minor\_breaks} but I typically do not need to change those.
By default the major breaks are determined by \textit{ggplot2} based on the data, but I want to control them myself.
The very start of the script holds the creation of the \textbf{ytimes} list, and after adding 0 to the vector and rounding to two places, those are the breaks I want.

Directly related to the breaks are the labels for the breaks.
By default they are just the values for the breaks, which is acceptable for MsBetweenPresents, but not for MsBetweenDisplayChange, so I do want to address them.
You can, like with \textbf{breaks} supply a vector or list for the values you want shown as the labels, but you can also use a function instead.
This function will be run on the break values to produce the labels, which is why I made custom \textbf{labelRound}, \textbf{labelBreak}, and \textbf{labelDisp} functions.
The \textbf{labelRound} does exactly that, so I could skip rounding within the breaks and use this function, but I decided not to.
The \textbf{labelBreak} function adds line breaks to every other label, to help avoid overlap and is used for the X scale, but is not necessary on a Y scale.
Lastly I have \textbf{labelDisp}, which converts the breaks value to be in refresh cycles for a 60 Hz monitor.

The \textbf{limits} argument is probably also self-explanatory, though I do want to point out my use of \textbf{FtimeLimit} here.
The value of that variable is set in the Input script, making it possible to control the upper limit for this scale, and others, from a single line.
Usually I do not need to touch it, but I did for this article, so that ability to change one thing to affect all of the graphs was definitely nice.

The \textbf{expand} argument is to control how much padding around the scale is applied.
Instead of having the edges of the plot be at the limits of the scales, \textit{ggplot2} will expand the plot a little further, providing some separation that can look good to the eye.
It is controlled with a vector containing two values, with the first being a multiplier and the second additive.
I have it set to use the multiplying coefficient, because that means that however great the limits are, the padding should appear consistent, while an additive value would appear different for different scale sizes.
An analogy for text would be using 1.5 spacing, which uses line spacing derived from the size of the font, and setting a fixed spacing of say 15 pt.
When the font size changes, the 1.5 spacing changes with it while 15 pt remains 15 pt.
I consistently use this vector with the \textbf{expand} argument.

Lastly we have \textbf{sec.axis}, which adds a secondary axis.
In this case I just have it duplicating the axis with \textbf{dup\_axis}, but it is also possible to create a completely different scale for this other axis.
I just want the axis duplicated so you do not need to look as far to find the values on the scale.

\begin{styleR}
ggplot(data = results, aes(x = GPU, y = get(datatype))) +
ggtitle(gameQ, subtitle = paste0(datatype, " - Means, Medians, and Percentiles")) + labsGPU +
geom_hline(yintercept = 1000/60, color = "red") +
# geom_boxplot(outlier.alpha = 0) +
stat_summary(fun.data = BoxPerc, geom = "boxplot", width = 0.6) +
geom_bar(aes(fill = GPU), stat = "summary", fun.y = "mean") + scale_fill_hue() +
stat_summary(fun.data = BoxPerc, geom = "boxplot", alpha = 0.25, width = 0.6) +
# geom_boxplot(alpha = 0.50, outlier.alpha = 0.1) +
facet_grid(rows = vars(API), cols = vars(Location), switch = "y") +
scale_x_discrete(labels = labelBreak) +
scale_Y +
guides(fill = guide_legend(nrow = 1)) + theme(legend.position = "bottom")
\end{styleR}

Now we come to the code that will actually create the graph.
At the top I have \textbf{ggplot}, which opens the graph, and in this case does a little more.
Though not necessary, arguments can be passed to \textbf{ggplot} and these will carry over to other layers.
The first argument I am using is \textbf{data}, and as the name suggests it is the data object the plots should get values from for building the plots.
The second I am using is \textbf{aes} for aesthetics, and the arguments for the aesthetics controls how the data is mapped to the visual properties, the aesthetics of the graph layers.

Within \textbf{aes} we can see I set \textbf{x}, the X value, to be GPU, and the layers will interpret that to mean they need to look at the GPU column in the \textbf{data} object, which is \textbf{results}.
I also set \textbf{y}, the Y value, the output of the \textbf{get} function.
There is no column named datatype, but the \textbf{datatype} variable does hold the name of a column.
The \textbf{get} function will pass that name as an object to the graph, which enables me to use a variable as a reference and still have everything work.

Connecting the layers of the graph together are addition symbols, and the next line of code holds the \textbf{ggtitle} layer and the \textbf{labsGPU} variable I set earlier.
The \textbf{ggtitle} layer is one of the ways to assign labels to a graph, including the title and subtitle.
It is also possible to apply a caption with it, but there is nothing wrong with how I have that separate with \textbf{labsGPU}.

Though I do not name the argument, the first argument is assumed to be the title for the graph and is \textbf{gameQ}, the name of the game, or article in this case, with the name of the quality configuration pasted on.
The subtitle, which is placed immediately under the title in the graph, uses \textbf{paste0} to combine the value assigned to \textbf{datatype} with a description of what the graph is showing.
For this one it is "Means, Medians, and Percentiles" with a hyphen separating the data type and this string.
The \textbf{labsGPU} variable is then applied, adding the \textbf{labs} label with or without the \textbf{caption} argument.

The next line adds a geometric layer, specifically a horizontal line, which is why it is named \textbf{geom\_hline}.
Its arguments are the \textbf{yintercept} and the color, but it could be more complicated than this.
I just want to have a line marking where 60 FPS, or 16.667 ms is, and I have it colored red.
The \textbf{color} argument, and some others, can be supplied for any geometric layer, both inside and outside the \textbf{aes} argument.
When outside \textbf{aes} the value will be fixed, so this line is red no matter what the data is, but when inside it is possible to have things like the color change with the data.
If I placed this argument inside \textbf{aes} it actually would not instruct the graph to have the line be red, but that the color should be based on the value of the "red" data.
We will see how this works shortly.

The next line is another geometric layer, but it is commented out.
If it were active, it would add a box plot, or box and whisker plot to be more accurate, as a layer to the graph.
I do not want the default box plot though, but I leave this here as a reminder.
It has an argument of \textbf{outlier.alpha} that I have set to zero.
The default box plot will not only draw the box and whiskers but also dots to mark the outliers, but because I do not want to trust its definition of an outlier, I do not want them shown.
Setting an alpha value to zero makes the thing invisible.

To get a custom box plot, the \textbf{stat\_summary} layer can be used, with its \textbf{geom} argument set to be "boxplot."
The \textbf{fun.data} argument is for setting the function applied to the data, which is then fed into the \textbf{geom} argument, and I want to use the \textbf{BoxPerc} function I wrote earlier.
This will use the 0.1\%, 1\%, 99\%, and 99.9\% percentiles for the ends of the whiskers and box, and it also keeps the median for the center line of the box, which is the same as the default.
Because I set the data object and aesthetics for X and Y in the \textbf{ggplot} layer, this layer will inherit that information, so it is not necessary to restate it here, but \textbf{stat\_summary} does also take \textbf{data} and \textbf{aes} arguments.
The \textbf{width} argument is then set to 0.6 so the box is not too wide.

Next we have \textbf{geom\_bar}, which adds a bar plot as a layer.
While it does inherit from \textbf{ggplot}, I still want to set a new aesthetic value for it, in order to have the fill color of the bars change based on the GPU.
This is achieved just by setting the \textbf{fill} argument to GPU, which has it look to the GPU column in \textbf{results}.
If I wanted all of the bars to be the same color, I would set \textbf{fill} outside the aesthetics, like I set \textbf{color} for the \textbf{geom\_hline} earlier.

Coming out of \textbf{aes} we have the \textbf{stat} argument, which will override how the layer works with \textbf{stat\_count}.
Normally the \textbf{geom\_bar} layer is meant to produce bars with a height proportional to the number of cases in the groups passed to it, while \textbf{geom\_col} will have the heights be the values in the data.
What I want is for the height of the bar to be the arithmetic mean of the data, so I use the \textbf{stat} argument to override how the layer normally works to make the height a summary value for the data.
The \textbf{fun.y} sets the function used on the Y data to get that summary value.

That closes the layer but not the line as I have the \textbf{scale\_fill\_hue} layer too.
Scales in \textit{ggplot2} are not just for the axes, but almost any aesthetic that will represent the values in the data, including the fill color.
The hue scale tries to use colors evenly spaced on the color wheel to represent categorical data, which in this case is the discrete data of the GPUs.
The default values for the arguments for this layer are satisfactory to me, so I just need to call the layer for them to be applied.
The default fill colors are not as acceptable to me.

This next layer hopefully looks familiar as it is almost identical to the one before that adds the custom box plots to the graph.
The difference is that this one has the \textbf{alpha} argument and it is set to 0.25.
This means opacity of the layer is just 25\%.
The reason I have done this relates to the fact \textit{ggplot2} goes through these layers in order, so by having the \textbf{geom\_bar} layer after the first custom box plots, those bars will be placed on top of the boxes.
I want the boxes to be visible though, so I need a layer with them after the bars, but then the bars may be obscured.
My solution is to sandwich the bar between two layers, with the layer on top being mostly transparent.
This allows the bar to be visible, through the transparent layer, while the opaque layer hides the transparency when the bar stops.
It does not look very good to have the background of the plot show through the boxes.

Like before I have a commented out line that would add a default box plot.
It has an \textbf{alpha} argument too, but also the \textbf{outlier.alpha} argument is not set to zero, which means the outlier points will be visible.
They are mostly transparent though, which would indicate their lack of importance, if this layer were active.

Now we come to a feature of \textit{ggplot2} that I have definitely been enjoying for a while now; faceting.
With faceting it is possible to have multiple plots present in a single graph, and while these plots will be different, they can also be set to share things like scales.
The \textbf{facet\_grid} layer will have the facets placed on a grid, and is what I use, but there is also \textbf{facet\_wrap}.
It instead places the plots on a ribbon and then wraps them into the two-dimensional space of the graph.

The key arguments for \textbf{facet\_grid} are \textbf{rows} and \textbf{cols} as you assign to these the variables you want to have the plots grouped by, and the dimension you want them on.
I have the rows of the plots set to be the different APIs and the columns to be the different locations.
As we will see later, it is possible to supply more than one variable for these.
It is important that the variables used here are factors, as that is what the faceting layers expect, but it should also be noted that you may want to order the factors yourself.
This ordering will carry over to the facets, which would otherwise use alphabetical ordering.
It is also worth noting it tends to use a top-down and left-right ordering for facets, but I prefer different directions, so I address that later.

The third argument I set is \textbf{switch}, which serves a fairly simply function.
By default the facet labels for the rows is on the right side of the graph, but I prefer it on the left, so by passing "y" to \textbf{switch}, it switches the placement of the labels along the Y scale to the other side.
You can use "x" to put the labels at the top to the bottom, and "both" to move both axes to their, respective, opposite sides.

The \textbf{scale\_x\_discrete} layer is actually not strictly necessary, as \textit{ggplot2} correctly interprets the X scale to be discrete as well as its breaks and such.
This is also why none of its arguments are called up and edited within this layer, because the defaults are all correct.
All I want is to apply the \textbf{labelBreak} function to prevent the labels from overlapping.

After that scale is set, the \textbf{scale\_Y} variable adds the layer for the Y scale that I already configured.

Lastly we have a couple layers for controlling the legend.
The \textbf{guides} layer states that the legend concerning the \textbf{fill} aesthetic should be a single row.
The \textbf{theme} layer then has the \textbf{legend.position} argument set to place the legend on the bottom.
Working with the guides and themes can get a little complicated, with the host of things they can control and influence; especially the theme, which is why I try to not touch it too much.

\subsubsection{Course Graph}
\begin{styleR}
graphCOURSE	=	function(datatype)	{
	if	(datatype == "MsBetweenPresents")	{
		scale_Y	=	scale_y_continuous(
			name		=	"Frame Time (ms)",
			breaks		=	c(0, round(ytimes, 2)),
			limits		=	c(0, FtimeLimit),
			expand		=	c(0.02, 0),
			sec.axis	=	dup_axis()
		)
	}
	if	(datatype == "MsBetweenDisplayChange")	{
		scale_Y	=	scale_y_continuous(
			name		=	"Refresh Cycles Later (1/60 s)",
			breaks		=	c(0, round(ytimes, 2)),
			labels		=	labelDisp,
			limits		=	c(0, FtimeLimit),
			expand		=	c(0.02, 0),
			sec.axis	=	dup_axis()
		)
	}
	if	(datatype == "MsUntilRenderComplete")	{
		scale_Y	=	scale_y_continuous(
			name		=	"Render Time (ms)",
			breaks		=	c(0, round(ytimes, 2)),
			limits		=	c(0, FtimeLimit),
			expand		=	c(0.02, 0),
			sec.axis	=	dup_axis()
		)
	}
	if	(datatype == "MsEstimatedDriverLag")	{
		scale_Y	=	scale_y_continuous(
			name		=	"Estimated Driver Lag (ms)",
			breaks		=	c(0, round(ytimes, 2)),
			limits		=	c(0, FtimeLimit),
			expand		=	c(0.02, 0),
			sec.axis	=	dup_axis()
		)
	}

	if	(length(unique(results$Location)) == 1)	{
		ALPHA	=	1
	}	else	{
		ALPHA	=	0.05
	}

	ggplot(data = results, aes(x = TimeInSeconds, y = get(datatype))) +
	ggtitle(gameQ, subtitle = paste0(datatype, " - Course")) + labsGPU +
	geom_hline(yintercept = 1000/60, color = "red") +
	geom_point(alpha = ALPHA) +
	geom_smooth(method="gam", formula= y ~ s(x, bs = "cs")) +
	facet_grid(rows = vars(Location, API), cols = vars(GPU), switch = "y") +
	scale_x_continuous(name="Time (s)", breaks=seq(from=0, to=max(results$TimeInSeconds), by=60), labels = labelBreak, expand=c(0.02, 0)) +
	scale_Y
}
\end{styleR}

Now the graph we are making the function for is my Course graph that shows the measurements over the length of the recordings.
The configurations for the \textbf{scale\_Y} variable is the same as for the Means graph, so I will skip over that, and as much of the code for the graph too, but there are still things to cover.

\begin{styleR}
if	(length(unique(results$Location)) == 1)	{
	ALPHA	=	1
}	else	{
	ALPHA	=	0.05
}
\end{styleR}

This checks if the data is for a single location, because my single-location graphs have always had completely opaque points to them.
For the faceted graphs with multiple locations, however, I have the points almost completely transparent, so the darkness is an indication of density.
I definitely think the transparent points look better for the faceted graphs and I could probably use them for the single-location graphs too, but with the larger size of the single-location graphs, I do not think this effect is as necessary.

\begin{styleR}
ggplot(data = results, aes(x = TimeInSeconds, y = get(datatype))) +
ggtitle(gameQ, subtitle = paste0(datatype, " - Course")) + labsGPU +
geom_hline(yintercept = 1000/60, color = "red") +
geom_point(alpha = ALPHA) +
geom_smooth(method="gam", formula= y ~ s(x, bs = "cs")) +
facet_grid(rows = vars(Location, API), cols = vars(GPU), switch = "y") +
scale_x_continuous(name="Time (s)", breaks=seq(from=0, to=max(results$TimeInSeconds), by=60), labels = labelBreak, expand=c(0.02, 0)) +
scale_Y
\end{styleR}

The construction of \textbf{ggplot} is very similar to what we just had, but now the X value is set to the TimeInSeconds data.
The \textbf{ggtitle} layer too is similar to what we had before, so no need to go over it, and the \textbf{geom\_hline} layer is exactly identical.

The first truly new layer we have is \textbf{geom\_point}.
This will plot the data using the aesthetics set in \textbf{ggplot}, inheriting the X value to be the time in the recording and the Y value is whatever data type I am asking for.
Its transparency value is then set to either be completely opaque or mostly transparent using the \textbf{ALPHA} variable set earlier.

The \textbf{geom\_smooth} layer is the one responsible for the blue line on the course plots.
It will produce a smooth line from the data.
I actually could place it without any arguments, as its default behavior is acceptable to me, but because that behavior involves automatically selecting the smoothing function, I decided to explicitly state the function.
The layer works by using a function to smooth the data, and it has multiple built in.
It will select what it thinks is the best to use based on the amount of data it has to work with, and with the thousands of points in my data, it normally selects "gam" for generalized additive model.
As you can see in the code, I have the method manually set to that, and then a formula is set, which I found is the default formula the layer uses with "gam."

The \textbf{facet\_grid} layer is a bit different from what it was for Means.
Now the variable for \textbf{cols} is the GPU and there are two variables for \textbf{rows}, Location and API, in that order.
The order does matter and you can see in the graphs the plots for the locations are grouped together, and then the API plots for each location are shown.
If the order were reversed, then the API would be the top-level group, with each location covered within it, and that I think is not as useful.
I want to see how the different APIs behave at the same location, so Location is the first variable and API the second.

Now we have \textbf{scale\_x\_continuous} with I think only two of the arguments being interesting.
One is the use of \textbf{labelBreak} for the labels, and the other is the sequence I use for the breaks.
To keep the X scale from being over-populated with labels, I want it to have breaks just every 60 seconds, so I have this sequence set to generate values from 0 to the maximum time in the data, and use a step of 60.
Technically I could just set it to go to 300, but this way I can vary the length of the recordings without needing to change a value anywhere.

Lastly the \textbf{scale\_Y} variable is applied with the \textbf{scale\_y\_continuous} layer inside.

\subsubsection{Consecutive Difference Graph}
This graph is a bit different and a bit more complicated than those we have already looked at.
This is because both axes need to be changed for the data types, and the need to use a temporary variable to hold some data.

\begin{styleR}
graphDIFF	=	function(datatype, diffLim = 1000/50)	{
	if	(datatype == "MsBetweenPresents")	{
		scale_X	=	scale_x_continuous(
			name	=	"Frame Time (ms)",
			breaks	=	c(0, round(ytimes, 2)),
			limits	=	c(0, FtimeLimit),
			expand	=	c(0.02, 0)
		)
		scale_Y	=	scale_y_continuous(
			name	=	"Consecutive Frame Time Difference (ms)",
			breaks	=	c(0, round(ytimes, 2)),
			limits	=	c(-diffLim, diffLim),
			expand	=	c(0, 0)
		)
	}
	if	(datatype == "MsBetweenDisplayChange")	{
		scale_X	=	scale_x_continuous(
			name	=	"Refresh Cycles Later (1/60 s)",
			breaks	=	c(0, round(ytimes, 2)),
			labels	=	labelDisp,
			limits	=	c(0, FtimeLimit),
			expand	=	c(0.02, 0)
		)
		scale_Y	=	scale_y_continuous(
			name	=	"Consecutive Display Time Difference (ms)",
			breaks	=	c(0, round(ytimes, 2)),
			limits	=	c(-diffLim, diffLim),
			expand	=	c(0, 0)
		)
	}
	if	(datatype == "MsUntilRenderComplete")	{
		scale_X	=	scale_x_continuous(
			name	=	"Render Time (ms)",
			breaks	=	c(0, round(ytimes, 2)),
			limits	=	c(0, FtimeLimit),
			expand	=	c(0.02, 0)
		)
		scale_Y	=	scale_y_continuous(
			name	=	"Consecutive Render Time Difference (ms)",
			breaks	=	c(0, round(ytimes, 2)),
			limits	=	c(-diffLim, diffLim),
			expand	=	c(0, 0)
		)
	}
	if	(datatype == "MsEstimatedDriverLag")	{
		scale_X	=	scale_x_continuous(
			name	=	"Estimated Driver Lag (ms)",
			breaks	=	c(0, round(ytimes, 2)),
			limits	=	c(0, FtimeLimit),
			expand	=	c(0.02, 0)
		)
		scale_Y	=	scale_y_continuous(
			name	=	"Consecutive Lag Difference (ms)",
			breaks	=	c(0, round(ytimes, 2)),
			limits	=	c(-diffLim, diffLim),
			expand	=	c(0, 0)
		)
	}

	temp	=	eval(parse(text = paste0("results$", datatype)))
	#	this is to grab the desired column from the data frame
	#	the [1,] is needed because it otherwise just gets the list of row names
	#		cannot use the subsetting method because it has the wrong data type

	ggplot(data = results, aes(x = get(datatype), y = rbind(c(diff(temp), 0))[1,]) ) +
	ggtitle(gameQ, subtitle=paste0(datatype, " Consecutive Differences")) + labsGPU +
	geom_point(alpha = 0.1) +
	stat_density_2d(geom = "polygon", aes(fill = stat(nlevel)), show.legend = FALSE) + scale_fill_viridis_c() +
	# stat_density_2d(geom = "polygon", aes(fill = stat(nlevel), alpha = stat(nlevel)), show.legend = FALSE) +  scale_fill_viridis_c() +
	facet_grid(rows = vars(Location, API), cols = vars(GPU), switch = "y") +
	scale_X +
	scale_Y
}
\end{styleR}

When I was first developing this graph, I did try different limits for the consecutive difference scale, ultimately settling on 1000/50, in both directions.
I find this looks good and usually holds the data pretty well too, but I have seen times when some points appear to have vanished, but this is very uncommon.
In case I ever want to change the limits again, this limit is an argument for easy access and experimentation.

\begin{styleR}
if	(datatype == "MsBetweenPresents")	{
	scale_X	=	scale_x_continuous(
		name	=	"Frame Time (ms)",
		breaks	=	c(0, round(ytimes, 2)),
		limits	=	c(0, FtimeLimit),
		expand	=	c(0.02, 0)
	)
	scale_Y	=	scale_y_continuous(
		name	=	"Consecutive Frame Time Difference (ms)",
		breaks	=	c(0, round(ytimes, 2)),
		limits	=	c(-diffLim, diffLim),
		expand	=	c(0, 0)
	)
}
\end{styleR}

Instead of setting just one scale, I need to set both for this graph because at least the names should be different between the data types.
Everything else is similar to what we have seen before though, so it is not necessary to go through the code.

\begin{styleR}
temp	=	eval(parse(text = paste0("results$", datatype)))
\end{styleR}

This line will assign to the temporary variable, \textbf{temp}, the column from the data for the desired data type.
Because I want to run a function, the \textbf{diff} function specifically, on the data, I cannot use \textbf{get} like I have been, but the combination of \textbf{eval} and \textbf{parse} get the job done.

\begin{styleR}
ggplot(data = results, aes(x = get(datatype), y = rbind(c(diff(temp), 0))[1,]) ) +
ggtitle(gameQ, subtitle=paste0(datatype, " Consecutive Differences")) + labsGPU +
geom_point(alpha = 0.1) +
stat_density_2d(geom = "polygon", aes(fill = stat(nlevel)), show.legend = FALSE) + scale_fill_viridis_c() +
# stat_density_2d(geom = "polygon", aes(fill = stat(nlevel), alpha = stat(nlevel)), show.legend = FALSE) +  scale_fill_viridis_c() +
facet_grid(rows = vars(Location, API), cols = vars(GPU), switch = "y") +
scale_X +
scale_Y
\end{styleR}

Like before \textbf{ggplot} has its \textbf{data} argument set, and then within the \textbf{aes} argument the X value is set using the \textbf{get} function.
The Y value is a little different and weird though, because it was necessary to combine a few things to get what I want.
The \textbf{diff} function being applied to the \textbf{temp} data makes sense, but this is then combined with a 0.
This is because the length of the output from \textbf{diff} will be one less than the original data, and I need the dimensions to be the same.
I could also place the 0 at the beginning, but by having it at the end, the Y value of any point will direct us to the next point.
The 0 at the beginning would Y value would tell us what the previous measurement was, and I feel looking forward is better than looking back.
The \textbf{rbind} function is needed because it will actually stick the 0 at the end, as just having them both in the vector will not do, because the output from \textbf{diff}, in this case, is not a vector.

Keeping things weird, I need to identify a specific row be grabbed, using the square brackets.
I am not entirely sure why, but the output from \textbf{rbind} and the rest will actually have the row numbers looked at instead of the values.
This corrects that, but I could not tell you why it happens in the first place.

Just like the Course graph above, \textbf{geom\_point} inherits what it needs to from \textbf{ggplot}, so it is not necessary to provide any additional arguments to it, except for \textbf{alpha}.
Some additional arguments are needed for the \textbf{stat\_density\_2d} layer though, which is what adds the heat maps, as I call them, to the plots.

The first argument it has is \textbf{geom}, where I tell it I want polygons to be drawn for the density levels.
Other options would provide contour lines for each density level or a density map covering the entire plot.
To set it so the density levels are colored based on the density the \textbf{aes} argument is necessary and then the \textbf{fill} color is set to use the calculated variable of \textbf{nlevel}.
Some of the \textit{ggplot2} layers will produce variables of their own, and these variables can then be accessed and used.
In this case, \textbf{nlevel} identifies the normalized height of the contour line.
Other variables would be just \textbf{level}, which is not normalized, \textbf{density}, and \textbf{ndensity}, which are the density estimate and normalized version of that estimate.
By using the normalized variable, the apparent density value cannot be compared between plots, but within the same plot the density can be compared.

With the \textbf{show.legend} argument set to FALSE, the legend for indicating the meaning of the colors is not shown, which I think is fine because the values are normalized anyway.
It also means there is more room for the plots.

The \textbf{scale\_fill\_viridis\_c} layer sets the coloring for the levels in the density map to a set of colors I feel have a nice contrast between them, making the levels easy to distinguish.
At least this is the case when you have them all, thanks to the normalized densities.
If the densities were not normalized then some of the plots would not show all of the colors, if the density in one plot is sufficiently lower than another, which is rather likely with the different GPU performance levels.

The next line of code is nearly identical to this last one.
The difference is the \textbf{alpha} argument that is also set to \textbf{nlevel}.
Originally I thought it was a good idea to have the density map's transparency change with the density, but I have since changed my mind.
Still, I keep the original code so I can go back if I ever wish to.

The rest of the code is similar to what we had before, so we can move on to the next graph.

\subsubsection{Frequency Graph}
\begin{styleR}
graphFREQ	=	function(datatype)	{
	if	(datatype == "MsBetweenPresents")	{
		STATS	=	graphSTATS
		scale_X	=	scale_x_continuous(
			name	=	"Frame Time (ms)",
			breaks	=	c(0, round(ytimes, 2)),
			labels	=	labelRound,
			limits	=	c(0,  FtimeLimit),
			expand	=	c(0.02, 0)
		)
	}
	if	(datatype == "MsBetweenDisplayChange")	{
		STATS	=	dispgSTATS
		scale_X	=	scale_x_continuous(
			name	=	"Refresh Cycles Later (1/60 s)",
			breaks	=	c(0, round(ytimes, 2)),
			labels	=	labelDisp,
			limits	=	c(0, FtimeLimit),
			expand	=	c(0.02, 0)
		)
	}
	if	(datatype == "MsUntilRenderComplete")	{
		STATS	=	rendgSTATS
		scale_X	=	scale_x_continuous(
			name	=	"Render Time (ms)",
			breaks	=	c(0, round(ytimes, 2)),
			labels	=	labelRound,
			limits	=	c(0,  FtimeLimit),
			expand	=	c(0.02, 0)
		)
	}
	if	(datatype == "MsEstimatedDriverLag")	{
		STATS	=	drivgSTATS
		scale_X	=	scale_x_continuous(
			name	=	"Estimated Driver Lag (ms)",
			breaks	=	c(0, round(ytimes, 2)),
			labels	=	labelRound,
			limits	=	c(0,  FtimeLimit),
			expand	=	c(0.02, 0)
		)
	}
	STATS$GPU	=	factor(STATS$GPU, levels = listGPU, ordered = TRUE)

	ggplot(results, aes(get(datatype))) +
	ggtitle(gameQ, subtitle=paste0(datatype, " - Frequency Plot")) + labsGPU +
	geom_vline(xintercept = 1000/60, color = "red") +
	geom_freqpoly(binwidth=0.03, size=0) +
		geom_vline(data = STATS, aes(xintercept = Mean), color = "darkgreen") +
		geom_vline(data = STATS, aes(xintercept = Median), color = "darkcyan", linetype="dotdash") +
	facet_grid(rows = vars(Location, API), cols = vars(GPU), switch = "y") +
	scale_X +
	scale_y_continuous(name="Count", expand=c(0.02, 0))
}
\end{styleR}

The Frequency graph is definitely simpler than the Consecutive Difference graph, but because of my addition of lines for the arithmetic mean and the median, it is slightly more complicated than the other two graphs.
We can see this change immediately in the \textbf{if} statements for the data types.

\begin{styleR}
if	(datatype == "MsBetweenPresents")	{
	STATS	=	graphSTATS
	scale_X	=	scale_x_continuous(
		name	=	"Frame Time (ms)",
		breaks	=	c(0, round(ytimes, 2)),
		labels	=	labelRound,
		limits	=	c(0,  FtimeLimit),
		expand	=	c(0.02, 0)
	)
}
\end{styleR}

In order to place the lines for those two statistics into the plots, it is necessary to have access to the \textbf{graphSTATS} variable I made earlier, and the similar variables for the other data types.
To make the access regular, I have it set in these statements to assign the value to the new \textbf{STATS} variable.
There is nothing much else to note, except perhaps the use of \textbf{labelRound} on the labels, but we have already seen how functions can be used this way.
Also I have a line for setting the order of the GPUs in \textbf{STATS}, which does not seem necessary, but does not hurt to have.

\begin{styleR}
ggplot(results, aes(get(datatype))) +
ggtitle(gameQ, subtitle=paste0(datatype, " - Frequency Plot")) + labsGPU +
geom_vline(xintercept = 1000/60, color = "red") +
geom_freqpoly(binwidth=0.03, size=0) +
	geom_vline(data = STATS, aes(xintercept = Mean), color = "darkgreen") +
	geom_vline(data = STATS, aes(xintercept = Median), color = "darkcyan", linetype="dotdash") +
facet_grid(rows = vars(Location, API), cols = vars(GPU), switch = "y") +
scale_X +
scale_y_continuous(name="Count", expand=c(0.02, 0))
\end{styleR}

The first layer to this plot that is interesting is \textbf{geom\_freqpoly}, which is what creates the frequency plot.
Actually it is creating a frequency polygon, which is how it gets its name.
In any case, I have two arguments set for it, with the more generic one being \textbf{size}.
This just sets the size of the line used to be quite thin, because I do not like the default thickness.
The \textbf{binwidth} argument controls how wide the bins are that are used to count the number of measurements at certain values.
A larger value will produce higher counts, but the plot looks less detailed, while a smaller value shows more noise in the plot.
I did experiment some when creating the graph and found 0.03 to be the visually most appealing to me.

The next two layers are for adding the vertical lines for the mean and median.
Both use the \textbf{STATS} data frame to get the value from, which is important because while it can be possible to have the plot calculate these values directly from the data, this does not always work well with the facets.
This approach, however, does ensure the correct values are used for each plot.

To distinguish between the lines, I have different colors set, but also the median has a different line type combining dots and dashes.
The mean line will be solid, the default.

\subsubsection{QQ Graph}
You may be a little surprised when you look at the code for this graph, because while there is a geometry layer to create QQ plots in \textit{ggplot2}, this is actually the most complicated graph, even compared to the Consecutive Difference graph.

\begin{styleR}
graphQQ	=	function(datatype)	{
	if	(datatype == "MsBetweenPresents")	{
		STATS	=	graphSTATS
		scale_Y	=	scale_y_continuous(
			name	=	"Frame Time (ms)",
			breaks	=	c(0, round(ytimes, 2)),
			labels	=	labelRound,
			expand	=	c(0.02, 0)
		)
	}
	if	(datatype == "MsBetweenDisplayChange")	{
		STATS	=	dispgSTATS
		scale_Y	=	scale_y_continuous(
			name	=	"Refresh Cycles Later (1/60 s)",
			breaks	=	c(0, round(ytimes, 2)),
			labels	=	labelDisp,
			expand	=	c(0.02, 0)
		)
	}
	if	(datatype == "MsUntilRenderComplete")	{
		STATS	=	rendgSTATS
		scale_Y	=	scale_y_continuous(
			name	=	"Render Time (ms)",
			breaks	=	c(0, round(ytimes, 2)),
			labels	=	labelRound,
			expand	=	c(0.02, 0)
		)
	}
	if	(datatype == "MsEstimatedDriverLag")	{
		STATS	=	drivgSTATS
		scale_Y	=	scale_y_continuous(
			name	=	"Estimated Driver Lag (ms)",
			breaks	=	c(0, round(ytimes, 2)),
			labels	=	labelRound,
			expand	=	c(0.02, 0)
		)
	}
	STATS$GPU	=	factor(STATS$GPU, levels = listGPU, ordered = TRUE)

#	sec.axis	=	sec_axis(~.,
#		breaks	=	STATS[c("0.1", "1", "Median", "99", "99.9")],
#		labels	=	paste0(round(STATS[c("0.1", "1", "Median", "99", "99.9")], 2), c(" (0.1%)", " (1%)", " (50%)", " (99%)", " (99.9%)"))
#	)
#		this can be used to add a secondary axis that shows the values for the percentiles
#			it needs to be put in place after STATS is assigned, else it throws an error

	ggplot(data = STATS, aes(ymin = -Inf, xmin = -Inf)) +
	ggtitle(gameQ, subtitle = paste0(datatype, " - QQ Distribution")) + labsGPU +
	geom_hline(yintercept = 1000/60, color	=	"red") +
		geom_rect(aes(ymax = get("0.1"),	xmax = qnorm(.001)), alpha=0.1, fill=c("blue"), color = "grey") +
		geom_rect(aes(ymax = get("1"),		xmax = qnorm(.010)), alpha=0.1, fill=c("blue"), color = "grey") +
		geom_rect(aes(ymax = get("Median"),	xmax = qnorm(.500)), alpha=0.1, fill=c("blue"), color = "grey") +
		geom_rect(aes(ymax = get("99"),		xmax = qnorm(.990)), alpha=0.1, fill=c("red"), color = "grey") +
		geom_rect(aes(ymax = get("99.9"),	xmax = qnorm(.999)), alpha=0.1, fill=c("red"), color = "grey") +
	stat_qq_line(data = results, aes(sample=get(datatype)), line.p = QUAN, color = "green", size = 1.1, linetype = "dotted") +
	stat_qq(data = results, aes(sample=get(datatype))) +
	stat_qq_line(data = results, aes(sample=get(datatype)), line.p = QUAN, color = "green", alpha = 0.5, size = 1.1, linetype = "dotted") +
	geom_label(data = STATS, aes(x = Inf, y = -Inf, label = paste0("Slope: ", Slope)), parse = TRUE, hjust="right", vjust="bottom", fill = "darkgrey", color = "green") +
	facet_grid(rows = vars(Location, API), cols = vars(GPU), switch = "y") +
	scale_Y + coord_cartesian(ylim = c(0, FtimeLimit)) +
	scale_x_continuous(name="Percentile", breaks=qnorm(c(.001, .01, .5, .99, .999)), labels=labelBreak(c("0.1", "1", "50", "99", "99.9")), minor_breaks=NULL, expand=c(0.02, 0))
}
\end{styleR}

Like I said, it is the most complicated of the graphs, because I have returned things to it I had previously dropped, and added some new things too.
Fortunately, a lot of it repeats what we have already seen in other the graphs.

\begin{styleR}
if	(datatype == "MsBetweenPresents")	{
	STATS	=	graphSTATS
	scale_Y	=	scale_y_continuous(
		name	=	"Frame Time (ms)",
		breaks	=	c(0, round(ytimes, 2)),
		labels	=	labelRound,
		expand	=	c(0.02, 0)
	)
	...
}
STATS$GPU	=	factor(STATS$GPU, levels = listGPU, ordered = TRUE)
#	sec.axis	=	sec_axis(~.,
#		breaks	=	STATS[c("0.1", "1", "Median", "99", "99.9")],
#		labels	=	paste0(round(STATS[c("0.1", "1", "Median", "99", "99.9")], 2), c(" (0.1%)", " (1%)", " (50%)", " (99%)", " (99.9%)"))
#	)
#		this can be used to add a secondary axis that shows the values for the percentiles
#			it needs to be put in place after STATS is assigned, else it throws an error
\end{styleR}

The creation of the \textbf{scale\_Y} and \textbf{STATS} variable are nothing new, but there is the commented code I want to address.
This is for adding a special secondary axis that will mark the values of the percentiles 0.1\%, 1\%, 99\%, 99.9\%, and the median on the right side of the plot.
As these values are all specifically given within the tables I share, I do not feel it is necessary to include them here, but at the same time I do not want to throw away the code.
It is also a good idea to not use them because of the potential for overlap as some of these values can be right next to each other and I have no way to automatically correct that.

For the Frequency graph I mentioned that I added the code to apply an order to the GPUs in the \textbf{STATS} data frame, but that it was not necessary.
Here it is because when I did not have the order set, a different order was used, so that line of code is necessary here.

\begin{styleR}
ggplot(data = STATS, aes(ymin = -Inf, xmin = -Inf)) +
ggtitle(gameQ, subtitle = paste0(datatype, " - QQ Distribution")) + labsGPU +
geom_hline(yintercept = 1000/60, color	=	"red") +
	geom_rect(aes(ymax = get("0.1"),	xmax = qnorm(.001)), alpha=0.1, fill=c("blue"), color = "grey") +
	geom_rect(aes(ymax = get("1"),		xmax = qnorm(.010)), alpha=0.1, fill=c("blue"), color = "grey") +
	geom_rect(aes(ymax = get("Median"),	xmax = qnorm(.500)), alpha=0.1, fill=c("blue"), color = "grey") +
	geom_rect(aes(ymax = get("99"),		xmax = qnorm(.990)), alpha=0.1, fill=c("red"), color = "grey") +
	geom_rect(aes(ymax = get("99.9"),	xmax = qnorm(.999)), alpha=0.1, fill=c("red"), color = "grey") +
stat_qq_line(data = results, aes(sample=get(datatype)), line.p = QUAN, color = "green", size = 1.1, linetype = "dotted") +
stat_qq(data = results, aes(sample=get(datatype))) +
stat_qq_line(data = results, aes(sample=get(datatype)), line.p = QUAN, color = "green", alpha = 0.5, size = 1.1, linetype = "dotted") +
geom_label(data = STATS, aes(x = Inf, y = -Inf, label = paste0("Slope: ", Slope)), parse = TRUE, hjust="right", vjust="bottom", fill = "darkgrey", color = "green") +
facet_grid(rows = vars(Location, API), cols = vars(GPU), switch = "y") +
scale_Y + coord_cartesian(ylim = c(0, FtimeLimit)) +
scale_x_continuous(name="Percentile", breaks=qnorm(c(.001, .01, .5, .99, .999)), labels=labelBreak(c("0.1", "1", "50", "99", "99.9")), minor_breaks=NULL, expand=c(0.02, 0))
\end{styleR}

This looks like a lot of code, and it is, but a lot of it is repeated, so it is not as bad as it appears.
The first thing that is worth noting is that the \textbf{data} and aesthetics arguments in \textbf{ggplot} are different than what we have been using.
This is because the layers go in order, and the lowest layers are rectangles I had to drop when I started using faceted graphs.
These rectangles were to mark the percentiles and median on the graph, tracing the percentile value to the line and then over to the data value.
The values to build these rectangles are in \textbf{STATS}, so that is the \textbf{data} argument.
When it comes time to use the data held in \textbf{results}, the \textbf{data} argument will be used to specify that.

Now we come to the \textbf{geom\_rect} layers, which inherit the \textbf{data}, \textbf{ymin}, and \textbf{xmin} values set earlier.
This just leaves the \textbf{ymax} and \textbf{xmax} aesthetics as well as the \textbf{alpha}, \textbf{fill}, and \textbf{color} arguments.
The \textbf{ymax} values are those in the \textbf{STATS} data frame, so the \textbf{get} command can be used to select the appropriate columns, just like we have been doing with \textbf{results}.
It is necessary to identify the names as strings, as some are numbers otherwise, and while \textbf{get} might not be necessary for the Median column, I still use it if only so the lines like similar.

The \textbf{xmax} value is a fairly easy to get here as it just requires the value returned by \textbf{qnorm}.
Though the labels are changed, the breaks for the X axis are actually Z scores and the \textbf{qnorm} function will return the Z score that corresponds to a specific quantile.

To distinguish between the rectangles, I am using both transparency and color.
Rather than require a different color for each rectangle, I make them mostly transparent so the layering of them changes the color.
The lower three I have blue in color and the upper two I have red, which I find gives the desired look I want.
The \textbf{color} argument is for the edge of the rectangles and I have it set to grey so it is present but does not stand out too much.

With the \textbf{stat\_qq\_line} we get to the first layer that needs to look to the \textbf{results} data.
This layer appears twice for the same reason the \textbf{stat\_summary} layers are there twice in the Means graph; to avoid obscuring the data.
Besides needing the \textbf{data} to be set, the actual data to sample must also be identified within the aesthetics mapping.
Be default the line goes between the 25\% and 75\% values (the first and third quartiles), but I want to use different values, which is where the \textbf{line.p} argument comes in.
It requires a vector of two elements be provided to it, and that is already set in the Input script to be for 1\% and 99\%.
After that \textbf{color} is set to green, which is nicely visible, \textbf{size} is set to 1.1 so it is a little thicker than usual, and \textbf{linetype} to dotted.
I want the line to be dotted to make it easier to see the data behind it, which is also why the second \textbf{stat\_qq\_line} has \textbf{alpha} set to 0.5.

The layer sandwiched between the lines is \textbf{stat\_qq} which just needs to be given an object for \textbf{data} and told what the \textbf{sample} should be.
The defaults for the rest of it are find with me, and the layer will then order and place the points to create a QQ plot.
Well, kind of since only one scale is quantiles, but the layer name is QQ, so I keep calling it a QQ plot anyway.

There is yet another geometry layer to be concerned with and it is \textbf{geom\_label}.
This and its sister layer \textbf{geom\_text} are for adding text to a plot, with \textbf{geom\_label} placing a box around the text to make it easier to read.
The value I want shown is the slope of the QQ line, which is in \textbf{STATS}, so I set that to \textbf{data}.
That might not be necessary, if the layer would still inherit from \textbf{ggplot}, but it does not hurt to have it (aside from being a longer line of code).
Again with the aesthetics I am using the \textbf{Inf} special word to place the label on the lower right of the plots, regardless of the actual edges of the plots.
The label is then set to be a string identifying the value as the slope, and then grabbing the value from \textbf{data}.

Coming outside of the data-driven aesthetics, the \textbf{parse} argument is TRUE, but it honestly does not matter.
When TRUE the labels will be parsed into expressions, but it still works when this is FALSE.
There is a little difference in the placement of the text within the label rectangle though, and I like it a bit better when TRUE, so it is.
To keep the label box from going outside of the plot, the horizontal justification (\textbf{hjust}) and vertical justification (\textbf{vjust}) are set to be right and bottom, respectively.
The \textbf{color} for the text and border of the box are set to be green, matching the line concerned, so \textbf{fill} is set to dark grey, as the green shows up nicely on it.

The \textbf{facet\_grid} and \textbf{scale\_Y} layers have been covered before, but \textbf{coord\_cartesian} is something new and very useful.
There is an unfortunate quirk to \textit{ggplot2} and that is whenever a part of an object to be drawn is outside of the plot’s scales, the whole object will not be drawn.
For \textbf{stat\_qq} this is not an issue as it just means the points outside the plot are missing, but for the \textbf{geom\_rect} and \textbf{stat\_qq\_line}, it could be an issue if one of the points defining them is above the \textbf{FtimeLimit} value.
It would cause that entire layer to be skipped, but thankfully \textbf{coord\_cartesian} provides a solution.

The \textbf{coord\_cartesian} layer acts different with how it applies limits, as it does not prevent objects outside of its limits from being drawn, but it does remove them as a result of the cropping of the graph.
Though the reason I added this I believe I have resolved by other means, it is still good to have at least one example of in all of this, because it can be very annoying when something is not appearing and you do not know why.

The last layer is \textbf{scale\_x\_continuous}, which is important because it places the major breaks at the interested percentiles and then makes sure the labels are as percentiles, and not quantiles or the Z-scores that would normally be shown on a QQ plot.
It also disables the minor breaks which would not actually be too helpful anyway, since the X scale is not linear.

\subsubsection{Graph Output Function}

With the functions for the different graphs made, we can finally get to actually creating the graphs and saving them.
For that I have one more custom function.

\begin{styleR}
graphOUT	=	function(datatype, graphtype, OUT = TRUE, diffLim = NULL, ...)	{
	if	(datatype == "MsBetweenPresents")			dataNAME	=	"Frame Time"
	if	(datatype == "MsBetweenDisplayChange")		dataNAME	=	"Display Time"
	if	(datatype == "MsUntilRenderComplete")		dataNAME	=	"Render Time"
	if	(datatype == "MsEstimatedDriverLag")		dataNAME	=	"Driver Lag"

	if	(substitute(graphtype) == "graphMEANS")		graphNAME	=	"Means"
	if	(substitute(graphtype) == "graphCOURSE")	graphNAME	=	"Course"
	if	(substitute(graphtype) == "graphFREQ")		graphNAME	=	"Freq"
	if	(substitute(graphtype) == "graphQQ")		graphNAME	=	"QQ"
	if	(substitute(graphtype) == "graphDIFF")		graphNAME	=	"Diff"

	#ARGS	=	list(...)
	#	how to get the miscellaneous arguments into a variable

	message(paste0(graphNAME, " - ", dataNAME))

	if	(graphNAME == "Diff" & !is.null(diffLim))	{
		PLOT	=	graphtype(datatype, diffLim)
	}	else	{
		PLOT	=	graphtype(datatype)
	}

	if	(OUT)	customSave(paste0("@", graphNAME, " - ", dataNAME), plot = PLOT, ...)
	PLOT	#shows the current graph, but must be after customSave
}
\end{styleR}

As it serves a similar purpose to the \textbf{sinkTXT}, \textbf{sinkHTML}, and \textbf{sinkOUT} functions I made earlier, I am naming it \textbf{graphOUT}.
It requires four arguments, and the first true cannot have defaults.
These are \textbf{datatype}, serving the exact same purpose as it did for the graph functions, and \textbf{graphtype}.
The \textbf{diffLIM} argument is there just to be passed to the Consecutive Difference graph, in case I want to change it, and then \textbf{OUT} is to control if I want to save the graph.
Usually I do, but there may be times I want to just look at the graph in the R GUI, so I would set it to FALSE.
There is also the ellipsis among the arguments and this is to pass any arguments to the \textbf{customSave} functions, such as the width or height different from the default.

\begin{styleR}
if	(datatype == "MsBetweenPresents")			dataNAME	=	"Frame Time"
...
if	(substitute(graphtype) == "graphMEANS")		graphNAME	=	"Means"
...
\end{styleR}

As the two groups of \textbf{if} statements were identical but for some particulars, I am just using these two lines as examples.
These lines are necessary for naming the graphs appropriately.
The first one checks what the \textbf{datatype} argument is and then sets the \textbf{dataNAME} variable to be a friendly name for the file name.
The second is a little more complicated because of the \textbf{substitute} function.
What it will do is return the parsed value of the variable, without evaluating it.
This is necessary because while the value assigned to \textbf{datatype} needs to be a string, \textbf{graphtype} is actually the graph function.
With \textbf{substitute} we get the name of the function as a string, so we can compare it against the names as strings.
Depending on the result, \textbf{graphNAME} is set to a friendlier name of the graph.
The next bit of code is something I commented out but want there as a note to myself.
In order to get the arguments provided by the ellipsis, one can just assign the ellipsis as a list to a variable, and then work from that variable.
I do not need to do that here, but it is useful to remember.

\begin{styleR}
message(paste0(graphNAME, " - ", dataNAME))

if	(graphNAME == "Diff" & !is.null(diffLim))	{
	PLOT	=	graphtype(datatype, diffLim)
}	else	{
	PLOT	=	graphtype(datatype)
}

if	(OUT)	customSave(paste0("@", graphNAME, " - ", dataNAME), plot = PLOT, ...)
PLOT	#shows the current graph, but must be after customSave
\end{styleR}

The \textbf{message} function will identify the current graph being worked on, which is valuable when this is running in the console window.
This next bit of code is to cover when it is a Consecutive Difference graph being worked on, and the limits for the difference axis need to be changed.
In that scenario, the \textbf{graphDIFF} function assigned to \textbf{graphtype} will be given the values of \textbf{datatype} and \textbf{diffLim} as arguments.
Otherwise, \textbf{graphtype} is just given \textbf{datatype}.
In both scenarios, the graph is not actually created but assigned to the \textbf{PLOT} variable.
The reason for this is because of how the \textbf{ggsave} function within my \textbf{customSave} function works.
Normally it will use whatever the last-drawn graph is, but it can also be given a graph for it to save directly.
By assigning the graph to \textbf{PLOT} I can pass it to \textbf{customSave} so it is saved directly.
If I am doing tweaking or experiments, this can be very helpful as a way to avoid accidentally saving the wrong graph.
Before the graph is saved though, the \textbf{if} statement quickly checks if the graph should be saved.
If it should be, then the \textbf{customSave} function is run with all of the information it needs.
If it should not be, then the last line of the function is \textbf{PLOT}, which will tell the R GUI to render the graph.
Perhaps it would be appropriate to have it only render \textbf{PLOT} if it is set to not be saved, but it is also very likely that I will want to see the graph if I am in the R GUI.

With that function gone through, it is time to start actually making the graphs.
First though, the order of the APIs needs to be changed.

\begin{styleR}
results$API	=	factor(results$API, levels = rev(listAPI))
\end{styleR}

I do not like the bottom-up order \textit{ggplot2} will use normally, so I reverse the APIs to address this.

\begin{styleR}
#Means
if	(graphFRAM)	graphOUT("MsBetweenPresents",		graphMEANS)
if	(graphDISP)	graphOUT("MsBetweenDisplayChange",	graphMEANS)
if	(graphREND)	graphOUT("MsUntilRenderComplete",	graphMEANS)
if	(graphDRIV)	graphOUT("MsEstimatedDriverLag",	graphMEANS)
\end{styleR}

The first graphs to be created are the Means graphs for a specific reason that I will get to soon.
First this code checks if the graph for the data type is even desired, and if it is the \textbf{graphOUT} function is called with the appropriate arguments.
After this we get to the reason the Means graphs are made first.

\begin{styleR}
if	(useSHORT)	{
results							=	reLoc(results, shortLOC);		results		=	reAPI(results, shortAPI)

if	(graphFRAM)	{	graphSTATS	=	reLoc(graphSTATS, shortLOC);	graphSTATS	=	reAPI(graphSTATS, shortAPI)	}
if	(graphDISP)	{	dispgSTATS	=	reLoc(dispgSTATS, shortLOC);	dispgSTATS	=	reAPI(dispgSTATS, shortAPI)	}
if	(graphREND)	{	rendgSTATS	=	reLoc(rendgSTATS, shortLOC);	rendgSTATS	=	reAPI(rendgSTATS, shortAPI)	}
if	(graphDRIV)	{	drivgSTATS	=	reLoc(drivgSTATS, shortLOC);	drivgSTATS	=	reAPI(drivgSTATS, shortAPI)	}
}

results$Location						=	factor(results$Location, levels = rev(levels(results$Location)))
if	(graphFRAM)		graphSTATS$Location	=	factor(graphSTATS$Location, levels = rev(levels(graphSTATS$Location)))
if	(graphDISP)		dispgSTATS$Location	=	factor(dispgSTATS$Location, levels = rev(levels(dispgSTATS$Location)))
if	(graphREND)		rendgSTATS$Location	=	factor(rendgSTATS$Location, levels = rev(levels(rendgSTATS$Location)))
if	(graphDRIV)		drivgSTATS$Location	=	factor(drivgSTATS$Location, levels = rev(levels(drivgSTATS$Location)))
\end{styleR}

Normally the Means graphs do not need the shortened versions of the location and API names, and this code is what applies those names, where appropriate.
First it checks if the names are supposed to be used to begin with.
After that, it applies them using the \textbf{reLoc} and \textbf{reAPI} functions found in the Input script to the whole of \textbf{results}.
Because I think it looks nice to be on a single line, I am using the semi-colon to tell R to separate the two commands without a line break.

After \textbf{results} is changed, the different data frames of the graph-specific stats need to have the same work done to them.
Though we see the code as being on a single line, it is necessary to use the curly brackets with the \textbf{if} statements here, because the semi-colon will tell R the code for the statement has ended.

After the shortened names are applied, I want to reverse the order of the locations in the data.
It is just that I have a different preference for ordering it than R, making this necessary.
Because there is only one thing to do when the \textbf{if} statements are true, the semi-colon and thus the curly brackets too are not needed.

There is really nothing left to this script, except for the creation of the other graphs, but the pattern is identical to that for creating the Means graphs above.

\begin{styleR}
#Course
if	(graphFRAM)	graphOUT("MsBetweenPresents",		graphCOURSE)
if	(graphDISP)	graphOUT("MsBetweenDisplayChange",	graphCOURSE)
if	(graphREND)	graphOUT("MsUntilRenderComplete",	graphCOURSE)
if	(graphDRIV)	graphOUT("MsEstimatedDriverLag",	graphCOURSE)

#Frequency
if	(graphFRAM)	graphOUT("MsBetweenPresents",		graphFREQ)
if	(graphDISP)	graphOUT("MsBetweenDisplayChange",	graphFREQ)
if	(graphREND)	graphOUT("MsUntilRenderComplete",	graphFREQ)
if	(graphDRIV)	graphOUT("MsEstimatedDriverLag",	graphFREQ)

#QQ
if	(graphFRAM)	graphOUT("MsBetweenPresents",		graphQQ)
if	(graphDISP)	graphOUT("MsBetweenDisplayChange",	graphQQ)
if	(graphREND)	graphOUT("MsUntilRenderComplete",	graphQQ)
if	(graphDRIV)	graphOUT("MsEstimatedDriverLag",	graphQQ)

#Differnce
if	(graphFRAM)	graphOUT("MsBetweenPresents",		graphDIFF)
if	(graphDISP)	graphOUT("MsBetweenDisplayChange",	graphDIFF)
if	(graphREND)	graphOUT("MsUntilRenderComplete",	graphDIFF)
if	(graphDRIV)	graphOUT("MsEstimatedDriverLag",	graphDIFF)
\end{styleR}
